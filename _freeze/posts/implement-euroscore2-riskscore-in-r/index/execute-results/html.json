{
  "hash": "70e3376e269d31371a60266c279a956f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Implement EuroSCORE II risk score in R\"\nauthor: [\"Michael Dismorr\", \"Ruixin Lu\"]\ndate: \"2024-06-04\"\n# date-modified: \"2024-06-01\"\ncategories: [R, risk-score, euroscore, functions]\nimage: calculator.png\n---\n\n\nToday, I will show you a way to implement the [EuroSCORE II](https://www.euroscore.org) risk score in R. EuroSCORE is a risk score that tries to predict mortality after cardiac surgery, and is used in clincal practice to assess individual risk before surgery. This helps inform the patient (and surgeon) about the expected risk, and can also contribute in the decision making whether the patient will likely benefit the most from surgery, or some other procedure such as transcatheter aortic valve implantation (TAVI), depending on the issue at hand and co-morbidities.\nIf you just want to download function with same test data, you can do so [here](calc_euroscore.R)\n\n> EuroSCORE was created following a collaboration by researchers at Royal Papworth Hospital in Cambridge UK and the Centre Hospitalier Universitaire de Martinique.\n\nSince it's conception, it has been updated several times. The latest version is called the EuroSCORE II, and it is a logistic regression model. As stated in the [original publication](https://academic.oup.com/ejcts/article/41/4/734/646622) of EuroSCORE II:\n\n> Cardiac surgical mortality has significantly reduced in the last 15 years despite older and sicker patients. EuroSCORE II is better calibrated than the original model yet preserves powerful discrimination. It is proposed for the future assessment of cardiac surgical risk.\n\nAs you might know, a logistic model estimates the $\\log\\text{odds}$, and it's linear predictor can be written as:\n\n$$\\log\\text{odds} = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + ... \\beta_iX_i$$\n\nConsequently, the $e^{\\beta_i}$ can be interpreted as the odds ratio if all other covariates are held constant.\n\nLet's also do a quick recap what odds actually are. Odds are usually expressed as $\\frac{events}{non-events}$. Compare this to risk, which would be $\\frac{events}{events+non-events}$. So, to convert odds to risk, we can use the formula $Risk=\\frac{Odds}{1+Odds}$.\n\nLet's now explore this using R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate some example data\nset.seed(12345) # To make the results reproducible\nexample_data <- data.frame(outcome = rbinom(100, 1, 0.5), # Generate a binary outcome\n           group = sample(c(\"A\", \"B\"), 100, replace = T)) # Generate a random group assignment\n```\n:::\n\n\nNow, we can manually calculate the odds of the outcome per each group. Note that I will calculate risk using odds `risk_1`, and just using $Risk=\\frac{events}{non-events}$. Of course, they are identical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(broom)\nexample_data %>% group_by(group) %>% \n  summarise(events = sum(outcome == 1), \n            non_events = sum(outcome == 0), \n            odds = events/non_events, \n            risk = events/(events+non_events), \n            risk_1 = odds/(1+odds))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  group events non_events  odds  risk risk_1\n  <chr>  <int>      <int> <dbl> <dbl>  <dbl>\n1 A         26         21 1.24  0.553  0.553\n2 B         26         27 0.963 0.491  0.491\n```\n\n\n:::\n:::\n\n\nNow let's use a logistic regression model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg_mod <- glm(outcome ~ group, data = example_data, family = \"binomial\")\nsummary(reg_mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = outcome ~ group, family = \"binomial\", data = example_data)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)\n(Intercept)   0.2136     0.2934   0.728    0.467\ngroupB       -0.2513     0.4020  -0.625    0.532\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 138.47  on 99  degrees of freedom\nResidual deviance: 138.08  on 98  degrees of freedom\nAIC: 142.08\n\nNumber of Fisher Scoring iterations: 3\n```\n\n\n:::\n:::\n\n\nHere we fitted a logistic regression model, where the coefficients can be interpreted as the `log(odds)`. Now, let's convert that to odds (or odds ratios):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(reg_mod) %>% select(group = term, coef = estimate) %>% \n  mutate(OR = exp(coef))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  group         coef    OR\n  <chr>        <dbl> <dbl>\n1 (Intercept)  0.214 1.24 \n2 groupB      -0.251 0.778\n```\n\n\n:::\n:::\n\n\nThe `(Intercept)` here refers to Group A odds, but to obtain the odds for Group B we must add the coefficients together, otherwise it is the odds ratio of Group B over Group A.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(reg_mod$coefficients[1]+reg_mod$coefficients[2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n   0.962963 \n```\n\n\n:::\n:::\n\n\nAll the numbers are the same as our manual calculation (although the output is rounded differently). Now let's calculate the risk\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(reg_mod$coefficients[1])/(1+exp(reg_mod$coefficients[1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n  0.5531915 \n```\n\n\n:::\n:::\n\n\nThis function is actually built-in in the model object itself, and does the calculation much faster (which can be useful if you work with large data sets)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg_mod$family$linkinv(reg_mod$coefficients[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n  0.5531915 \n```\n\n\n:::\n:::\n\n\nUsing the linear predictor, the odds of Group A is:\n\n$$log_{odds}=\\beta_0 + \\beta_1Group_B*0$$ $$log_{odds[Group A]} = 0.2136 + (-0.2513*0)$$\n\nAnd consequently, the linear predictor for Group B is:\n\n$$log_{odds}=\\beta_0 + \\beta_1Group_B*1$$\n\n$$log_{odds[Group B]} = 0.2136 + (-0.2513*1)$$\n\nNow, let's implement the results from the EuroSCORE II logistic regression model as a function to estimate the EuroSCORE II in our own data sets.\nBelow are the coefficients as reported by the [EuroSCORE II publication](https://academic.oup.com/ejcts/article/41/4/734/646622)\nThey modeled age non-linearly, as stated in the article:  \n\n>βi the coefficient of the variable Xi, for age, Xi = 1 if patient age ≤60; Xi increases by one point per year thereafter (age 60 or less Xi = 1; age 61 if Xi = 2; age 62 if Xi = 3 and so on).\n\n| Variable.            | Coefficient |   |   |   |\n|----------------------|-------------|---|---|---|\n| NYHA                 |             |   |   |   |\n|  II                  | 0.1070545   |   |   |   |\n|  III                 | 0.2958358   |   |   |   |\n|  IV                  | 0.5597929   |   |   |   |\n| CCS4                 | 0.2226147   |   |   |   |\n| IDDM                 | 0.3542749   |   |   |   |\n| Age                  | 0.0285181   |   |   |   |\n| Female               | 0.2196434   |   |   |   |\n| ECA                  | 0.5360268   |   |   |   |\n| CPD                  | 0.1886564   |   |   |   |\n| N/M mob              | 0.2407181   |   |   |   |\n| Redo                 | 01.118599   |   |   |   |\n| Renal dysfunction    |             |   |   |   |\n|  On dialysis         | 0.6421508   |   |   |   |\n|  CC ≤ 50             | 0.8592256   |   |   |   |\n|  CC 50−85            | 0.303553    |   |   |   |\n| AE                   | 0.6194522   |   |   |   |\n| Critical             | 1.086517    |   |   |   |\n| LV function          |             |   |   |   |\n|  Moderate            | 0.3150652   |   |   |   |\n|  Poor                | 0.8084096   |   |   |   |\n|  Very poor           | 0.9346919   |   |   |   |\n| Recent MI            | 0.1528943   |   |   |   |\n| PA systolic pressure |             |   |   |   |\n|  31–55 mmHg          | 0.1788899   |   |   |   |\n|  ≥55                 | 0.3491475   |   |   |   |\n| Urgency              |             |   |   |   |\n|  Urgent              | 0.3174673   |   |   |   |\n|  Emergency           | 0.7039121   |   |   |   |\n|  Salvage             | 1.362947    |   |   |   |\n| Weight of procedure  |             |   |   |   |\n|  1 non-CABG          | 0.0062118   |   |   |   |\n|  2                   | 0.5521478   |   |   |   |\n|  3+                  | 0.9724533   |   |   |   |\n| Thoracic aorta       | 0.6527205   |   |   |   |\n| Constant             | −5.324537   |   |   |   |\n\nUsing this information, we can calculate the EuroSCORE II in a function by using a series of `mutate()` and `case_when()` statements. \n\n\n::: {.cell .column-screen-inset-shaded}\n\n```{.r .cell-code}\ncalc_euroscore <- function(data.frame) {\n\n   euroscore <- data.frame %>% mutate(est_NYHA = case_when(EURO_NYHA == 2 ~ 0.1070545, \n                                              EURO_NYHA == 3 ~ 0.2958358,\n                                              EURO_NYHA == 4 ~ 0.5597929,\n                                              EURO_NYHA == 1 ~ 0,\n                                              EURO_NYHA == 9 ~ NA_real_),\n                                      est_ccs4 = case_when(EURO_CCS4 == 9 ~ NA_real_,\n                                                           TRUE ~ 0.2226147 * EURO_CCS4),\n                                      est_IDDM = case_when(is.na(DIABETESINSULIN) ~ 0,\n                                                           .default = 0.3542749 * DIABETESINSULIN),\n                                      est_age = case_when(EURO_AGE <= 60 ~ 0.0285181,\n                                                          EURO_AGE > 60 ~ (EURO_AGE - 59) * 0.0285181),\n                                      est_female = case_when(EURO_SEX == 2 ~ 0.2196434,\n                                                             EURO_SEX == 1 ~ 0),\n                                      est_eca = case_when(EURO_EXTRACARDIAC == 9 ~ NA_real_,\n                                                          TRUE ~ 0.5360268 * EURO_EXTRACARDIAC),\n                                      est_cpd = case_when(EURO_CHRONICPULM == 9 ~ NA_real_,\n                                                          TRUE ~ 0.1886564 * EURO_CHRONICPULM),\n                                      est_neuro = case_when(EURO_POORMOBILITY == 9 ~ NA_real_,\n                                                            TRUE ~ 0.2407181 * EURO_POORMOBILITY),\n                                      est_PREVCARDSURG = case_when(EURO_PREVCARDSURG == 9 ~ NA_real_,\n                                                               TRUE ~ 1.118599 * EURO_PREVCARDSURG),\n                                      est_cc = case_when(DIALYS == 1 ~ 0.6421508,\n                                                         EURO_CREATININE_CLEAREANCE <= 50 ~ 0.8592256,\n                                                         EURO_CREATININE_CLEAREANCE > 50 & EURO_CREATININE_CLEAREANCE <= 85 ~ 0.303553,\n                                                         EURO_CREATININE_CLEAREANCE > 85 ~ 0),\n                                      est_AE = case_when(EURO_ENDOCARDITIS == 9 ~ NA_real_,\n                                                         TRUE ~ 0.6194522 * EURO_ENDOCARDITIS),\n                                      est_critical = case_when(EURO_CRITICAL == 9 ~ NA_real_,\n                                                               TRUE ~ 1.086517 * EURO_CRITICAL),\n                                      est_LV = case_when(EURO_VK_EJFRACT2 == 0 ~ 0,\n                                                         EURO_VK_EJFRACT2 == 1 ~ 0.3150652,\n                                                         EURO_VK_EJFRACT2 == 2 ~ 0.8084096,\n                                                         EURO_VK_EJFRACT2 == 3 ~ 0.9346919),\n                                      est_hjinf = case_when(EURO_HJINF == 9 ~ NA_real_,\n                                                            TRUE ~ 0.1528943 * EURO_HJINF),\n                                      est_pulmonchoice = case_when(EURO_PULMONCHOICE == 0 ~ 0, \n                                                                   EURO_PULMONCHOICE == 1 ~ 0.1788899,\n                                                                   EURO_PULMONCHOICE == 2 ~ 0.3491475), \n                                      est_urgency = case_when(EURO_URGENCY == 1 ~ 0,\n                                                              EURO_URGENCY == 2 ~ 0.3174673, \n                                                              EURO_URGENCY == 3 ~ 0.7039121,\n                                                              EURO_URGENCY == 4 ~ 1.362947),\n                                      est_weightofprocedure = case_when(EURO_WEIGHTOFPROCEDURE == 0 ~ 0,\n                                                                        EURO_WEIGHTOFPROCEDURE == 1 ~ 0.0062118,\n                                                                        EURO_WEIGHTOFPROCEDURE == 2 ~ 0.5521478,\n                                                                        EURO_WEIGHTOFPROCEDURE == 3 ~ 0.9724533),\n                                      est_THORACALAORTA = case_when(EURO_THORACALAORTA == 9 ~ NA_real_,\n                                                               TRUE ~ 0.6527205 * EURO_THORACALAORTA),\n                                      est_sum = est_NYHA + est_ccs4 + est_IDDM + est_age + est_female + est_eca + est_cpd + est_neuro +\n                                                est_PREVCARDSURG + est_cc + est_AE + est_critical + est_LV + est_hjinf + est_pulmonchoice +\n                                                est_urgency + est_weightofprocedure + est_THORACALAORTA,\n                                      euro_new = exp(-5.324537 + est_sum)/(1 + exp(-5.324537 + est_sum)),\n                                      euro_new = round(euro_new * 100, 2)) %>%\n                                      pull(euro_new)\n                                      \n\n                               return(euroscore)\n}\n```\n:::\n\n\nLet's try it out on a dummy data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data <- data.frame(EURO_NYHA = c(2, 9),\n                             EURO_CCS4 = c(1, 1),\n                             DIABETESINSULIN = c(1, NA), \n                             EURO_AGE = c(70, 9), \n                             EURO_SEX = c(2, 2),  \n                             EURO_EXTRACARDIAC = c(1, 1),\n                             EURO_CHRONICPULM = c(1, 9),\n                             EURO_POORMOBILITY = c(1, 1), \n                             EURO_PREVCARDSURG = c(1, 1), \n                             DIALYS = c(1, 0), \n                             EURO_CREATININE_CLEAREANCE = c(40, 40), \n                             EURO_ENDOCARDITIS = c(1, 9), \n                             EURO_CRITICAL = c(1, 9), \n                             EURO_VK_EJFRACT2 = c(2, 2), \n                             EURO_HJINF = c(1, 1),\n                             EURO_PULMONCHOICE = c(1, 1),\n                             EURO_URGENCY = c(1, 1),\n                             EURO_WEIGHTOFPROCEDURE = c(1, 1),\n                             EURO_THORACALAORTA = c(1, 1))\n\ncalc_euroscore(test_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 89.32    NA\n```\n\n\n:::\n:::\n\n\nThis is the same result as on the [EuroSCORE II calculator:](https://www.euroscore.org/index.php?id=17&lang=en)\n\n![EuroSCORE II calculator](calculator.png)\n\nA few closing remarks. You have to decide before hand how you want to handle missing data. In the current implementation, if anything is missing it will not calculate a EuroSCORE. In most cases, it might be reasonable to prepare the data set with `replace_na()` to chose some sort of default value. \nI would also like to thank our PhD student, Ruixin Lu for the help with developing this function when we needed it for one of our projects. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}